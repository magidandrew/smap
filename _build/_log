### Starting build.
# Target: src/smap.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/smap.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/smap.ml > src/smap.ml.depends
# Target: src/ast.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/ast.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/ast.ml > src/ast.ml.depends
# Target: src/codegen.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/codegen.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/codegen.ml > src/codegen.ml.depends
# Target: src/ast.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/ast.cmo, file:src/ast.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmo src/ast.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmo src/ast.ml
File "src/ast.ml", line 105, characters 25-557:
105 | .........................function
106 |     Int_lit(l) -> string_of_int l
107 |   | Float_lit(l) -> string_of_float l    (*check floats again*)
108 |   | Bool_lit(true) -> "true"
109 |   | Bool_lit(false) -> "false"
...
114 |   | Assign(v, o, e) -> string_of_expr v ^ " " ^ string_of_assign o ^ " " ^ string_of_expr e
115 |   | FunCall(f, el) ->
116 |       f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
117 |   | Noexpr -> ""
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Char_lit _|String_lit _|List_lit _|Cast (_, _)|ListElement (_, _, _)|
ListAddHead (_, _)|ListAddTail (_, _)|Length _|ProbColon (_, _)|Index _)
File "src/ast.ml", line 120, characters 25-653:
120 | .........................function
121 |     Block(stmts) ->
122 |       "{\n" ^ String.concat "" (List.map string_of_stmt stmts) ^ "}\n"
123 |   | Expr(expr) -> string_of_expr expr ^ ";\n";
124 |   | Return(expr) -> "return " ^ string_of_expr expr ^ ";\n";
...
128 |   | For(e1, e2, e3, s) ->
129 |       "for (" ^ string_of_expr e1  ^ " ; " ^ string_of_expr e2 ^ " ; " ^
130 |       string_of_expr e3  ^ ") " ^ string_of_stmt s
131 |   | While(e, s) -> "while (" ^ string_of_expr e ^ ") " ^ string_of_stmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Break|Continue|If (_, _)|If_Else (_, _)|If_Elif (_, _, _)|
If_Elif_Else (_, _, _, _)|Elif (_, _))
# Target: src/sast.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/sast.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/sast.ml > src/sast.ml.depends
# Target: src/sast.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/sast.cmo, file:src/sast.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmo src/sast.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmo src/sast.ml
File "src/sast.ml", line 53, characters 44-605:
53 | ............................................(match e with
54 |     SInt_lit(l) -> string_of_int l
55 |   | SFloat_lit(l) -> string_of_float l    (*check floats again*)
56 |   | SBool_lit(true) -> "true"
57 |   | SBool_lit(false) -> "false"
...
63 |   | SFunCall(f, el) ->
64 |       f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
65 |   | SNoexpr -> ""
66 | 				  )...............
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SString_lit _|SList_lit _|SCast (_, _)|SListElement (_, _)|
SListAddHead (_, _)|SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/sast.ml", line 68, characters 26-682:
68 | ..........................function
69 |     SBlock(stmts) ->
70 |       "{\n" ^ String.concat "" (List.map string_of_sstmt stmts) ^ "}\n"
71 |   | SExpr(expr) -> string_of_sexpr expr ^ ";\n";
72 |   | SReturn(expr) -> "return " ^ string_of_sexpr expr ^ ";\n";
...
77 |   | SFor(e1, e2, e3, s) ->
78 |       "for (" ^ string_of_sexpr e1  ^ " ; " ^ string_of_sexpr e2 ^ " ; " ^
79 |       string_of_sexpr e3  ^ ") " ^ string_of_sstmt s
80 |   | SWhile(e, s) -> "while (" ^ string_of_sexpr e ^ ") " ^ string_of_sstmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf (_, _)|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
# Target: src/parser.mly, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mly, file:src/parser.mly, infer, ocaml, ocamlyacc, parser, quiet, traverse }
/usr/bin/ocamlyacc src/parser.mly
# Target: src/parser.mli.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mli, file:src/parser.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/parser.mli > src/parser.mli.depends
# Target: src/scanner.mll, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mll, file:src/scanner.mll, lexer, ocaml, ocamllex, quiet, traverse }
/usr/bin/ocamllex.opt -q src/scanner.mll
# Target: src/scanner.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/scanner.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/scanner.ml > src/scanner.ml.depends
# Target: src/parser.cmi, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:mli, file:src/parser.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/parser.cmi src/parser.mli
# Target: src/semant.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/semant.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/semant.ml > src/semant.ml.depends
# Target: src/codegen.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/codegen.cmo, file:src/codegen.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmo src/codegen.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmo src/codegen.ml
File "src/codegen.ml", line 330, characters 4-312:
330 | ....(** for reference
331 |          %2 = alloca %struct.list*, align 8
332 |          store %struct.list* %1, %struct.list** %2, align 8, !dbg !26
333 | 
334 |          let tmpListPtr = L.build_alloca (L.pointer_type list_t) "tmpListPtr" builder in
335 |             let _ = ignore (L.build_store tmpList tmpListPtr builder); tmp'' in
336 |     *)
Warning 50: unattached documentation comment (ignored)
File "src/codegen.ml", line 65, characters 4-5:
65 |   | _ -> void_t (*add in prob, string, and list types later! *)
         ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 281, characters 16-21:
281 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 40: Float was selected from type Ast.typ.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 281, characters 16-21:
281 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 42: this use of Float relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 269, characters 10-11:
269 |         | _
                ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 273, characters 34-218:
273 | ..................................(match op with
274 |         A.Neg when t = [A.Float] -> L.build_fneg
275 |         | A.Neg
276 |         -> L.build_neg
277 |         | A.BitNot
278 |         -> L.build_not
279 |         | A.Not
280 |         -> L.build_not).................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Bang|Octothorpe)
File "src/codegen.ml", line 284, characters 3-468:
284 | ...(match op with
285 | 	    A.Add     -> L.build_fadd
286 | 	  | A.Sub     -> L.build_fsub
287 | 	  | A.Mul     -> L.build_fmul
288 | 	  | A.Div     -> L.build_fdiv
...
293 | 	  | A.CompGeq -> L.build_fcmp L.Fcmp.Oge
294 | 	  | A.BitAnd | A.BitOr ->
295 | 	      raise (Failure "internal error: semant should have rejected and/or on float")
296 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Concat|CompEq|RShift|LShift|Xor)
File "src/codegen.ml", line 300, characters 3-549:
300 | ...(match op with
301 | 	    A.Add     -> L.build_add
302 | 	  | A.Sub     -> L.build_sub
303 | 	  | A.Mul     -> L.build_mul
304 |     | A.Div     -> L.build_sdiv
...
313 |     | A.RShift  -> L.build_ashr
314 |     | A.LShift  -> L.build_lshr
315 |     | A.Xor     -> L.build_xor
316 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Concat
File "src/codegen.ml", line 321, characters 10-19:
321 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 40: PlusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 321, characters 10-19:
321 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 42: this use of PlusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 322, characters 10-20:
322 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: MinusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 322, characters 10-20:
322 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of MinusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 323, characters 10-20:
323 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: TimesEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 323, characters 10-20:
323 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of TimesEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 324, characters 10-18:
324 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 40: DivEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 324, characters 10-18:
324 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 42: this use of DivEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 325, characters 10-15:
325 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 40: Equal was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 325, characters 10-15:
325 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 42: this use of Equal relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 206, characters 42-7894:
206 | ..........................................match e with
207 |     SInt_lit i
208 |     -> L.const_int i32_t i
209 |     | SString_lit s
210 |     -> L.build_global_stringptr s "the_str" builder
...
386 |        let result = (match (List.hd fdecl.styp_name) with
387 |        A.Void -> ""
388 |        | _ -> f ^ "_result") in
389 |        L.build_call fdef (Array.of_list llargs) result builder
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SCast (_, _)|SListElement (_, _)|SListAddHead (_, _)|
SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/codegen.ml", line 397, characters 25-1851:
397 | .........................function
398 |     SBlock sl -> List.fold_left stmt builder sl
399 |     | SExpr e -> ignore(expr builder e); builder
400 |     | SReturn e -> ignore(match (List.hd fdecl.styp_name) with
401 |                                            (* Special "return nothing" instr *)
...
434 |         let bool_val = expr pred_builder p in
435 | 
436 |       ignore(L.build_cond_br bool_val body_bb merge_bb pred_builder);
437 |       L.builder_at_end context merge_bb
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
File "src/codegen.ml", line 85, characters 24-31:
85 |   let genGlobalListLit (typlist,exp) n m =
                             ^^^^^^^
Warning 27: unused variable typlist.
File "src/codegen.ml", line 93, characters 27-30:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                ^^^
Warning 27: unused variable v.
File "src/codegen.ml", line 93, characters 33-37:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                      ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 183, characters 8-22:
183 |     let int_format_str =
              ^^^^^^^^^^^^^^
Warning 26: unused variable int_format_str.
File "src/codegen.ml", line 195, characters 35-38:
195 |     and add_local m (SVdecl((t, n),exp)) = (* add locals to scope  *)
                                         ^^^
Warning 27: unused variable exp.
File "src/codegen.ml", line 225, characters 30-34:
225 |        ([A.Int],SInt_lit(v))::rest (* ([A.Int],SInt_lit(v))::rest *)
                                    ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 258, characters 16-21:
258 |             let aList = L.build_alloca (L.pointer_type list_t) "theList" in
                      ^^^^^
Warning 26: unused variable aList.
# Target: src/scanner.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/scanner.cmo, file:src/scanner.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/scanner.cmo src/scanner.ml
# Target: src/semant.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/semant.cmo, file:src/semant.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmo src/semant.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmo src/semant.ml
File "src/semant.ml", line 6, characters 16-26:
6 | module StdLib = Pervasives
                    ^^^^^^^^^^
Alert deprecated: module Stdlib.Pervasives
Use Stdlib instead.

If you need to stay compatible with OCaml < 4.07, you can use the 
stdlib-shims library: https://github.com/ocaml/stdlib-shims
File "src/semant.ml", line 147, characters 79-80:
147 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                                                     ^
Alert deprecated: Stdlib.&
Use (&&) instead.
File "src/semant.ml", line 263, characters 30-55:
263 |     let initLocals = List.map (fun (Some a) -> SExpr a)
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
None
File "src/semant.ml", line 61, characters 19-23:
61 |   let printBind nm typs acc = acc^" ("^nm^")," in
                        ^^^^
Warning 27: unused variable typs.
File "src/semant.ml", line 63, characters 34-35:
63 |   let asBindList = List.map (fun (k,v)-> printBindings v) asScopeList in
                                       ^
Warning 27: unused variable k.
File "src/semant.ml", line 70, characters 6-17:
70 |   let check_binds (kind : string) (binds : vdecl list) =
           ^^^^^^^^^^^
Warning 26: unused variable check_binds.
File "src/semant.ml", line 147, characters 50-53:
147 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                        ^^^
Warning 27: unused variable elt.
File "src/semant.ml", line 225, characters 34-53:
225 |   let check_for_init_local (Vdecl((typs,nm)as binding,e)) = match e with
                                        ^^^^^^^^^^^^^^^^^^^
Warning 26: unused variable binding.
# Target: src/smap.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/smap.cmo, file:src/smap.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/smap.cmo src/smap.ml
# Target: src/ast.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/ast.cmx, file:src/ast.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmx src/ast.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmx src/ast.ml
File "src/ast.ml", line 105, characters 25-557:
105 | .........................function
106 |     Int_lit(l) -> string_of_int l
107 |   | Float_lit(l) -> string_of_float l    (*check floats again*)
108 |   | Bool_lit(true) -> "true"
109 |   | Bool_lit(false) -> "false"
...
114 |   | Assign(v, o, e) -> string_of_expr v ^ " " ^ string_of_assign o ^ " " ^ string_of_expr e
115 |   | FunCall(f, el) ->
116 |       f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
117 |   | Noexpr -> ""
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Char_lit _|String_lit _|List_lit _|Cast (_, _)|ListElement (_, _, _)|
ListAddHead (_, _)|ListAddTail (_, _)|Length _|ProbColon (_, _)|Index _)
File "src/ast.ml", line 120, characters 25-653:
120 | .........................function
121 |     Block(stmts) ->
122 |       "{\n" ^ String.concat "" (List.map string_of_stmt stmts) ^ "}\n"
123 |   | Expr(expr) -> string_of_expr expr ^ ";\n";
124 |   | Return(expr) -> "return " ^ string_of_expr expr ^ ";\n";
...
128 |   | For(e1, e2, e3, s) ->
129 |       "for (" ^ string_of_expr e1  ^ " ; " ^ string_of_expr e2 ^ " ; " ^
130 |       string_of_expr e3  ^ ") " ^ string_of_stmt s
131 |   | While(e, s) -> "while (" ^ string_of_expr e ^ ") " ^ string_of_stmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Break|Continue|If (_, _)|If_Else (_, _)|If_Elif (_, _, _)|
If_Elif_Else (_, _, _, _)|Elif (_, _))
# Target: src/sast.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/sast.cmx, file:src/sast.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmx src/sast.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmx src/sast.ml
File "src/sast.ml", line 53, characters 44-605:
53 | ............................................(match e with
54 |     SInt_lit(l) -> string_of_int l
55 |   | SFloat_lit(l) -> string_of_float l    (*check floats again*)
56 |   | SBool_lit(true) -> "true"
57 |   | SBool_lit(false) -> "false"
...
63 |   | SFunCall(f, el) ->
64 |       f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
65 |   | SNoexpr -> ""
66 | 				  )...............
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SString_lit _|SList_lit _|SCast (_, _)|SListElement (_, _)|
SListAddHead (_, _)|SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/sast.ml", line 68, characters 26-682:
68 | ..........................function
69 |     SBlock(stmts) ->
70 |       "{\n" ^ String.concat "" (List.map string_of_sstmt stmts) ^ "}\n"
71 |   | SExpr(expr) -> string_of_sexpr expr ^ ";\n";
72 |   | SReturn(expr) -> "return " ^ string_of_sexpr expr ^ ";\n";
...
77 |   | SFor(e1, e2, e3, s) ->
78 |       "for (" ^ string_of_sexpr e1  ^ " ; " ^ string_of_sexpr e2 ^ " ; " ^
79 |       string_of_sexpr e3  ^ ") " ^ string_of_sstmt s
80 |   | SWhile(e, s) -> "while (" ^ string_of_sexpr e ^ ") " ^ string_of_sstmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf (_, _)|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
# Target: src/parser.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/parser.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/parser.ml > src/parser.ml.depends
# Target: src/parser.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/parser.cmx, file:src/parser.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/parser.cmx src/parser.ml
# Target: src/codegen.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/codegen.cmx, file:src/codegen.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmx src/codegen.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmx src/codegen.ml
File "src/codegen.ml", line 330, characters 4-312:
330 | ....(** for reference
331 |          %2 = alloca %struct.list*, align 8
332 |          store %struct.list* %1, %struct.list** %2, align 8, !dbg !26
333 | 
334 |          let tmpListPtr = L.build_alloca (L.pointer_type list_t) "tmpListPtr" builder in
335 |             let _ = ignore (L.build_store tmpList tmpListPtr builder); tmp'' in
336 |     *)
Warning 50: unattached documentation comment (ignored)
File "src/codegen.ml", line 65, characters 4-5:
65 |   | _ -> void_t (*add in prob, string, and list types later! *)
         ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 281, characters 16-21:
281 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 40: Float was selected from type Ast.typ.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 281, characters 16-21:
281 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 42: this use of Float relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 269, characters 10-11:
269 |         | _
                ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 273, characters 34-218:
273 | ..................................(match op with
274 |         A.Neg when t = [A.Float] -> L.build_fneg
275 |         | A.Neg
276 |         -> L.build_neg
277 |         | A.BitNot
278 |         -> L.build_not
279 |         | A.Not
280 |         -> L.build_not).................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Bang|Octothorpe)
File "src/codegen.ml", line 284, characters 3-468:
284 | ...(match op with
285 | 	    A.Add     -> L.build_fadd
286 | 	  | A.Sub     -> L.build_fsub
287 | 	  | A.Mul     -> L.build_fmul
288 | 	  | A.Div     -> L.build_fdiv
...
293 | 	  | A.CompGeq -> L.build_fcmp L.Fcmp.Oge
294 | 	  | A.BitAnd | A.BitOr ->
295 | 	      raise (Failure "internal error: semant should have rejected and/or on float")
296 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Concat|CompEq|RShift|LShift|Xor)
File "src/codegen.ml", line 300, characters 3-549:
300 | ...(match op with
301 | 	    A.Add     -> L.build_add
302 | 	  | A.Sub     -> L.build_sub
303 | 	  | A.Mul     -> L.build_mul
304 |     | A.Div     -> L.build_sdiv
...
313 |     | A.RShift  -> L.build_ashr
314 |     | A.LShift  -> L.build_lshr
315 |     | A.Xor     -> L.build_xor
316 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Concat
File "src/codegen.ml", line 321, characters 10-19:
321 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 40: PlusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 321, characters 10-19:
321 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 42: this use of PlusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 322, characters 10-20:
322 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: MinusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 322, characters 10-20:
322 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of MinusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 323, characters 10-20:
323 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: TimesEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 323, characters 10-20:
323 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of TimesEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 324, characters 10-18:
324 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 40: DivEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 324, characters 10-18:
324 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 42: this use of DivEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 325, characters 10-15:
325 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 40: Equal was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 325, characters 10-15:
325 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 42: this use of Equal relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 206, characters 42-7894:
206 | ..........................................match e with
207 |     SInt_lit i
208 |     -> L.const_int i32_t i
209 |     | SString_lit s
210 |     -> L.build_global_stringptr s "the_str" builder
...
386 |        let result = (match (List.hd fdecl.styp_name) with
387 |        A.Void -> ""
388 |        | _ -> f ^ "_result") in
389 |        L.build_call fdef (Array.of_list llargs) result builder
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SCast (_, _)|SListElement (_, _)|SListAddHead (_, _)|
SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/codegen.ml", line 397, characters 25-1851:
397 | .........................function
398 |     SBlock sl -> List.fold_left stmt builder sl
399 |     | SExpr e -> ignore(expr builder e); builder
400 |     | SReturn e -> ignore(match (List.hd fdecl.styp_name) with
401 |                                            (* Special "return nothing" instr *)
...
434 |         let bool_val = expr pred_builder p in
435 | 
436 |       ignore(L.build_cond_br bool_val body_bb merge_bb pred_builder);
437 |       L.builder_at_end context merge_bb
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
File "src/codegen.ml", line 85, characters 24-31:
85 |   let genGlobalListLit (typlist,exp) n m =
                             ^^^^^^^
Warning 27: unused variable typlist.
File "src/codegen.ml", line 93, characters 27-30:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                ^^^
Warning 27: unused variable v.
File "src/codegen.ml", line 93, characters 33-37:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                      ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 183, characters 8-22:
183 |     let int_format_str =
              ^^^^^^^^^^^^^^
Warning 26: unused variable int_format_str.
File "src/codegen.ml", line 195, characters 35-38:
195 |     and add_local m (SVdecl((t, n),exp)) = (* add locals to scope  *)
                                         ^^^
Warning 27: unused variable exp.
File "src/codegen.ml", line 225, characters 30-34:
225 |        ([A.Int],SInt_lit(v))::rest (* ([A.Int],SInt_lit(v))::rest *)
                                    ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 258, characters 16-21:
258 |             let aList = L.build_alloca (L.pointer_type list_t) "theList" in
                      ^^^^^
Warning 26: unused variable aList.
# Target: src/scanner.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/scanner.cmx, file:src/scanner.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/scanner.cmx src/scanner.ml
# Target: src/semant.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/semant.cmx, file:src/semant.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmx src/semant.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmx src/semant.ml
File "src/semant.ml", line 6, characters 16-26:
6 | module StdLib = Pervasives
                    ^^^^^^^^^^
Alert deprecated: module Stdlib.Pervasives
Use Stdlib instead.

If you need to stay compatible with OCaml < 4.07, you can use the 
stdlib-shims library: https://github.com/ocaml/stdlib-shims
File "src/semant.ml", line 147, characters 79-80:
147 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                                                     ^
Alert deprecated: Stdlib.&
Use (&&) instead.
File "src/semant.ml", line 263, characters 30-55:
263 |     let initLocals = List.map (fun (Some a) -> SExpr a)
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
None
File "src/semant.ml", line 61, characters 19-23:
61 |   let printBind nm typs acc = acc^" ("^nm^")," in
                        ^^^^
Warning 27: unused variable typs.
File "src/semant.ml", line 63, characters 34-35:
63 |   let asBindList = List.map (fun (k,v)-> printBindings v) asScopeList in
                                       ^
Warning 27: unused variable k.
File "src/semant.ml", line 70, characters 6-17:
70 |   let check_binds (kind : string) (binds : vdecl list) =
           ^^^^^^^^^^^
Warning 26: unused variable check_binds.
File "src/semant.ml", line 147, characters 50-53:
147 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                        ^^^
Warning 27: unused variable elt.
File "src/semant.ml", line 225, characters 34-53:
225 |   let check_for_init_local (Vdecl((typs,nm)as binding,e)) = match e with
                                        ^^^^^^^^^^^^^^^^^^^
Warning 26: unused variable binding.
# Target: src/smap.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/smap.cmx, file:src/smap.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/smap.cmx src/smap.ml
# Target: src/smap.native, tags: { package(llvm), package(llvm.analysis), warn(+a-4), dont_link_with, extension:native, file:src/smap.native, link, native, ocaml, program, quiet, traverse }
ocamlfind ocamlopt -linkpkg -package llvm -package llvm.analysis -I src src/ast.cmx src/sast.cmx src/codegen.cmx src/parser.cmx src/scanner.cmx src/semant.cmx src/smap.cmx -o src/smap.native
# Compilation successful.
