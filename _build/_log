### Starting build.
# Target: src/smap.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/smap.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/smap.ml > src/smap.ml.depends
# Target: src/ast.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/ast.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/ast.ml > src/ast.ml.depends
# Target: src/codegen.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/codegen.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/codegen.ml > src/codegen.ml.depends
# Target: src/ast.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/ast.cmo, file:src/ast.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmo src/ast.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmo src/ast.ml
File "src/ast.ml", line 105, characters 25-557:
105 | .........................function
106 |     Int_lit(l) -> string_of_int l
107 |   | Float_lit(l) -> string_of_float l    (*check floats again*)
108 |   | Bool_lit(true) -> "true"
109 |   | Bool_lit(false) -> "false"
...
114 |   | Assign(v, o, e) -> string_of_expr v ^ " " ^ string_of_assign o ^ " " ^ string_of_expr e
115 |   | FunCall(f, el) ->
116 |       f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
117 |   | Noexpr -> ""
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Char_lit _|String_lit _|List_lit _|Cast (_, _)|ListElement (_, _, _)|
ListAddHead (_, _)|ListAddTail (_, _)|Length _|ProbColon (_, _)|Index _)
File "src/ast.ml", line 120, characters 25-653:
120 | .........................function
121 |     Block(stmts) ->
122 |       "{\n" ^ String.concat "" (List.map string_of_stmt stmts) ^ "}\n"
123 |   | Expr(expr) -> string_of_expr expr ^ ";\n";
124 |   | Return(expr) -> "return " ^ string_of_expr expr ^ ";\n";
...
128 |   | For(e1, e2, e3, s) ->
129 |       "for (" ^ string_of_expr e1  ^ " ; " ^ string_of_expr e2 ^ " ; " ^
130 |       string_of_expr e3  ^ ") " ^ string_of_stmt s
131 |   | While(e, s) -> "while (" ^ string_of_expr e ^ ") " ^ string_of_stmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Break|Continue|If (_, _)|If_Else (_, _)|If_Elif (_, _, _)|
If_Elif_Else (_, _, _, _)|Elif (_, _))
# Target: src/sast.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/sast.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/sast.ml > src/sast.ml.depends
# Target: src/sast.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/sast.cmo, file:src/sast.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmo src/sast.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmo src/sast.ml
File "src/sast.ml", line 53, characters 44-605:
53 | ............................................(match e with
54 |     SInt_lit(l) -> string_of_int l
55 |   | SFloat_lit(l) -> string_of_float l    (*check floats again*)
56 |   | SBool_lit(true) -> "true"
57 |   | SBool_lit(false) -> "false"
...
63 |   | SFunCall(f, el) ->
64 |       f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
65 |   | SNoexpr -> ""
66 | 				  )...............
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SString_lit _|SList_lit _|SCast (_, _)|SListElement (_, _)|
SListAddHead (_, _)|SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/sast.ml", line 68, characters 26-682:
68 | ..........................function
69 |     SBlock(stmts) ->
70 |       "{\n" ^ String.concat "" (List.map string_of_sstmt stmts) ^ "}\n"
71 |   | SExpr(expr) -> string_of_sexpr expr ^ ";\n";
72 |   | SReturn(expr) -> "return " ^ string_of_sexpr expr ^ ";\n";
...
77 |   | SFor(e1, e2, e3, s) ->
78 |       "for (" ^ string_of_sexpr e1  ^ " ; " ^ string_of_sexpr e2 ^ " ; " ^
79 |       string_of_sexpr e3  ^ ") " ^ string_of_sstmt s
80 |   | SWhile(e, s) -> "while (" ^ string_of_sexpr e ^ ") " ^ string_of_sstmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf (_, _)|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
# Target: src/parser.mly, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mly, file:src/parser.mly, infer, ocaml, ocamlyacc, parser, quiet, traverse }
/usr/bin/ocamlyacc src/parser.mly
# Target: src/parser.mli.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mli, file:src/parser.mli, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/parser.mli > src/parser.mli.depends
# Target: src/scanner.mll, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:mll, file:src/scanner.mll, lexer, ocaml, ocamllex, quiet, traverse }
/usr/bin/ocamllex.opt -q src/scanner.mll
# Target: src/scanner.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/scanner.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/scanner.ml > src/scanner.ml.depends
# Target: src/parser.cmi, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:mli, file:src/parser.mli, interf, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/parser.cmi src/parser.mli
# Target: src/semant.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/semant.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/semant.ml > src/semant.ml.depends
# Target: src/codegen.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/codegen.cmo, file:src/codegen.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmo src/codegen.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmo src/codegen.ml
File "src/codegen.ml", line 327, characters 4-312:
327 | ....(** for reference
328 |          %2 = alloca %struct.list*, align 8
329 |          store %struct.list* %1, %struct.list** %2, align 8, !dbg !26
330 | 
331 |          let tmpListPtr = L.build_alloca (L.pointer_type list_t) "tmpListPtr" builder in
332 |             let _ = ignore (L.build_store tmpList tmpListPtr builder); tmp'' in
333 |     *)
Warning 50: unattached documentation comment (ignored)
File "src/codegen.ml", line 65, characters 4-5:
65 |   | _ -> void_t (*add in prob, string, and list types later! *)
         ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 278, characters 16-21:
278 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 40: Float was selected from type Ast.typ.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 278, characters 16-21:
278 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 42: this use of Float relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 266, characters 10-11:
266 |         | _
                ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 270, characters 34-218:
270 | ..................................(match op with
271 |         A.Neg when t = [A.Float] -> L.build_fneg
272 |         | A.Neg
273 |         -> L.build_neg
274 |         | A.BitNot
275 |         -> L.build_not
276 |         | A.Not
277 |         -> L.build_not).................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Bang|Octothorpe)
File "src/codegen.ml", line 281, characters 3-468:
281 | ...(match op with
282 | 	    A.Add     -> L.build_fadd
283 | 	  | A.Sub     -> L.build_fsub
284 | 	  | A.Mul     -> L.build_fmul
285 | 	  | A.Div     -> L.build_fdiv
...
290 | 	  | A.CompGeq -> L.build_fcmp L.Fcmp.Oge
291 | 	  | A.BitAnd | A.BitOr ->
292 | 	      raise (Failure "internal error: semant should have rejected and/or on float")
293 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Concat|CompEq|RShift|LShift|Xor)
File "src/codegen.ml", line 297, characters 3-549:
297 | ...(match op with
298 | 	    A.Add     -> L.build_add
299 | 	  | A.Sub     -> L.build_sub
300 | 	  | A.Mul     -> L.build_mul
301 |     | A.Div     -> L.build_sdiv
...
310 |     | A.RShift  -> L.build_ashr
311 |     | A.LShift  -> L.build_lshr
312 |     | A.Xor     -> L.build_xor
313 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Concat
File "src/codegen.ml", line 318, characters 10-19:
318 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 40: PlusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 318, characters 10-19:
318 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 42: this use of PlusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 319, characters 10-20:
319 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: MinusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 319, characters 10-20:
319 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of MinusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 320, characters 10-20:
320 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: TimesEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 320, characters 10-20:
320 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of TimesEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 321, characters 10-18:
321 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 40: DivEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 321, characters 10-18:
321 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 42: this use of DivEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 322, characters 10-15:
322 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 40: Equal was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 322, characters 10-15:
322 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 42: this use of Equal relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 203, characters 42-7777:
203 | ..........................................match e with
204 |     SInt_lit i
205 |     -> L.const_int i32_t i
206 |     | SString_lit s
207 |     -> L.build_global_stringptr s "the_str" builder
...
380 |        let result = (match (List.hd fdecl.styp_name) with
381 |        A.Void -> ""
382 |        | _ -> f ^ "_result") in
383 |        L.build_call fdef (Array.of_list llargs) result builder
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SCast (_, _)|SListElement (_, _)|SListAddHead (_, _)|
SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/codegen.ml", line 391, characters 25-1851:
391 | .........................function
392 |     SBlock sl -> List.fold_left stmt builder sl
393 |     | SExpr e -> ignore(expr builder e); builder
394 |     | SReturn e -> ignore(match (List.hd fdecl.styp_name) with
395 |                                            (* Special "return nothing" instr *)
...
428 |         let bool_val = expr pred_builder p in
429 | 
430 |       ignore(L.build_cond_br bool_val body_bb merge_bb pred_builder);
431 |       L.builder_at_end context merge_bb
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
File "src/codegen.ml", line 85, characters 24-31:
85 |   let genGlobalListLit (typlist,exp) n m =
                             ^^^^^^^
Warning 27: unused variable typlist.
File "src/codegen.ml", line 93, characters 27-30:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                ^^^
Warning 27: unused variable v.
File "src/codegen.ml", line 93, characters 33-37:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                      ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 180, characters 8-22:
180 |     let int_format_str =
              ^^^^^^^^^^^^^^
Warning 26: unused variable int_format_str.
File "src/codegen.ml", line 192, characters 35-38:
192 |     and add_local m (SVdecl((t, n),exp)) = (* add locals to scope  *)
                                         ^^^
Warning 27: unused variable exp.
File "src/codegen.ml", line 222, characters 30-34:
222 |        ([A.Int],SInt_lit(v))::rest (* ([A.Int],SInt_lit(v))::rest *)
                                    ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 255, characters 16-21:
255 |             let aList = L.build_alloca (L.pointer_type list_t) "theList" in
                      ^^^^^
Warning 26: unused variable aList.
# Target: src/scanner.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/scanner.cmo, file:src/scanner.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/scanner.cmo src/scanner.ml
# Target: src/semant.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/semant.cmo, file:src/semant.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmo src/semant.ml
+ ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmo src/semant.ml
File "src/semant.ml", line 6, characters 16-26:
6 | module StdLib = Pervasives
                    ^^^^^^^^^^
Alert deprecated: module Stdlib.Pervasives
Use Stdlib instead.

If you need to stay compatible with OCaml < 4.07, you can use the 
stdlib-shims library: https://github.com/ocaml/stdlib-shims
File "src/semant.ml", line 146, characters 79-80:
146 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                                                     ^
Alert deprecated: Stdlib.&
Use (&&) instead.
File "src/semant.ml", line 262, characters 30-55:
262 |     let initLocals = List.map (fun (Some a) -> SExpr a)
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
None
File "src/semant.ml", line 61, characters 19-23:
61 |   let printBind nm typs acc = acc^" ("^nm^")," in
                        ^^^^
Warning 27: unused variable typs.
File "src/semant.ml", line 63, characters 34-35:
63 |   let asBindList = List.map (fun (k,v)-> printBindings v) asScopeList in
                                       ^
Warning 27: unused variable k.
File "src/semant.ml", line 70, characters 6-17:
70 |   let check_binds (kind : string) (binds : vdecl list) =
           ^^^^^^^^^^^
Warning 26: unused variable check_binds.
File "src/semant.ml", line 146, characters 50-53:
146 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                        ^^^
Warning 27: unused variable elt.
File "src/semant.ml", line 224, characters 34-53:
224 |   let check_for_init_local (Vdecl((typs,nm)as binding,e)) = match e with
                                        ^^^^^^^^^^^^^^^^^^^
Warning 26: unused variable binding.
# Target: src/smap.cmo, tags: { package(llvm), package(llvm.analysis), warn(+a-4), byte, compile, extension:cmo, extension:ml, file:src/smap.cmo, file:src/smap.ml, implem, ocaml, quiet, traverse }
ocamlfind ocamlc -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/smap.cmo src/smap.ml
# Target: src/ast.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/ast.cmx, file:src/ast.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmx src/ast.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/ast.cmx src/ast.ml
File "src/ast.ml", line 105, characters 25-557:
105 | .........................function
106 |     Int_lit(l) -> string_of_int l
107 |   | Float_lit(l) -> string_of_float l    (*check floats again*)
108 |   | Bool_lit(true) -> "true"
109 |   | Bool_lit(false) -> "false"
...
114 |   | Assign(v, o, e) -> string_of_expr v ^ " " ^ string_of_assign o ^ " " ^ string_of_expr e
115 |   | FunCall(f, el) ->
116 |       f ^ "(" ^ String.concat ", " (List.map string_of_expr el) ^ ")"
117 |   | Noexpr -> ""
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Char_lit _|String_lit _|List_lit _|Cast (_, _)|ListElement (_, _, _)|
ListAddHead (_, _)|ListAddTail (_, _)|Length _|ProbColon (_, _)|Index _)
File "src/ast.ml", line 120, characters 25-653:
120 | .........................function
121 |     Block(stmts) ->
122 |       "{\n" ^ String.concat "" (List.map string_of_stmt stmts) ^ "}\n"
123 |   | Expr(expr) -> string_of_expr expr ^ ";\n";
124 |   | Return(expr) -> "return " ^ string_of_expr expr ^ ";\n";
...
128 |   | For(e1, e2, e3, s) ->
129 |       "for (" ^ string_of_expr e1  ^ " ; " ^ string_of_expr e2 ^ " ; " ^
130 |       string_of_expr e3  ^ ") " ^ string_of_stmt s
131 |   | While(e, s) -> "while (" ^ string_of_expr e ^ ") " ^ string_of_stmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Break|Continue|If (_, _)|If_Else (_, _)|If_Elif (_, _, _)|
If_Elif_Else (_, _, _, _)|Elif (_, _))
# Target: src/sast.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/sast.cmx, file:src/sast.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmx src/sast.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/sast.cmx src/sast.ml
File "src/sast.ml", line 53, characters 44-605:
53 | ............................................(match e with
54 |     SInt_lit(l) -> string_of_int l
55 |   | SFloat_lit(l) -> string_of_float l    (*check floats again*)
56 |   | SBool_lit(true) -> "true"
57 |   | SBool_lit(false) -> "false"
...
63 |   | SFunCall(f, el) ->
64 |       f ^ "(" ^ String.concat ", " (List.map string_of_sexpr el) ^ ")"
65 |   | SNoexpr -> ""
66 | 				  )...............
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SString_lit _|SList_lit _|SCast (_, _)|SListElement (_, _)|
SListAddHead (_, _)|SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/sast.ml", line 68, characters 26-682:
68 | ..........................function
69 |     SBlock(stmts) ->
70 |       "{\n" ^ String.concat "" (List.map string_of_sstmt stmts) ^ "}\n"
71 |   | SExpr(expr) -> string_of_sexpr expr ^ ";\n";
72 |   | SReturn(expr) -> "return " ^ string_of_sexpr expr ^ ";\n";
...
77 |   | SFor(e1, e2, e3, s) ->
78 |       "for (" ^ string_of_sexpr e1  ^ " ; " ^ string_of_sexpr e2 ^ " ; " ^
79 |       string_of_sexpr e3  ^ ") " ^ string_of_sstmt s
80 |   | SWhile(e, s) -> "while (" ^ string_of_sexpr e ^ ") " ^ string_of_sstmt s
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf (_, _)|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
# Target: src/parser.ml.depends, tags: { package(llvm), package(llvm.analysis), warn(+a-4), extension:ml, file:src/parser.ml, ocaml, ocamldep, quiet, traverse }
ocamlfind ocamldep -package llvm -package llvm.analysis -modules src/parser.ml > src/parser.ml.depends
# Target: src/parser.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/parser.cmx, file:src/parser.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/parser.cmx src/parser.ml
# Target: src/codegen.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/codegen.cmx, file:src/codegen.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmx src/codegen.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/codegen.cmx src/codegen.ml
File "src/codegen.ml", line 327, characters 4-312:
327 | ....(** for reference
328 |          %2 = alloca %struct.list*, align 8
329 |          store %struct.list* %1, %struct.list** %2, align 8, !dbg !26
330 | 
331 |          let tmpListPtr = L.build_alloca (L.pointer_type list_t) "tmpListPtr" builder in
332 |             let _ = ignore (L.build_store tmpList tmpListPtr builder); tmp'' in
333 |     *)
Warning 50: unattached documentation comment (ignored)
File "src/codegen.ml", line 65, characters 4-5:
65 |   | _ -> void_t (*add in prob, string, and list types later! *)
         ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 278, characters 16-21:
278 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 40: Float was selected from type Ast.typ.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 278, characters 16-21:
278 |     | SBinop (([Float],_ ) as e1, op, e2) ->
                      ^^^^^
Warning 42: this use of Float relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 266, characters 10-11:
266 |         | _
                ^
Warning 11: this match case is unused.
File "src/codegen.ml", line 270, characters 34-218:
270 | ..................................(match op with
271 |         A.Neg when t = [A.Float] -> L.build_fneg
272 |         | A.Neg
273 |         -> L.build_neg
274 |         | A.BitNot
275 |         -> L.build_not
276 |         | A.Not
277 |         -> L.build_not).................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Bang|Octothorpe)
File "src/codegen.ml", line 281, characters 3-468:
281 | ...(match op with
282 | 	    A.Add     -> L.build_fadd
283 | 	  | A.Sub     -> L.build_fsub
284 | 	  | A.Mul     -> L.build_fmul
285 | 	  | A.Div     -> L.build_fdiv
...
290 | 	  | A.CompGeq -> L.build_fcmp L.Fcmp.Oge
291 | 	  | A.BitAnd | A.BitOr ->
292 | 	      raise (Failure "internal error: semant should have rejected and/or on float")
293 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(Concat|CompEq|RShift|LShift|Xor)
File "src/codegen.ml", line 297, characters 3-549:
297 | ...(match op with
298 | 	    A.Add     -> L.build_add
299 | 	  | A.Sub     -> L.build_sub
300 | 	  | A.Mul     -> L.build_mul
301 |     | A.Div     -> L.build_sdiv
...
310 |     | A.RShift  -> L.build_ashr
311 |     | A.LShift  -> L.build_lshr
312 |     | A.Xor     -> L.build_xor
313 | 	  )......................
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
Concat
File "src/codegen.ml", line 318, characters 10-19:
318 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 40: PlusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 318, characters 10-19:
318 |           PlusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^
Warning 42: this use of PlusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 319, characters 10-20:
319 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: MinusEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 319, characters 10-20:
319 |         | MinusEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of MinusEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 320, characters 10-20:
320 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 40: TimesEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 320, characters 10-20:
320 |         | TimesEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^^^
Warning 42: this use of TimesEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 321, characters 10-18:
321 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 40: DivEqual was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 321, characters 10-18:
321 |         | DivEqual -> raise (Failure("special assignments need binops to be able to work"))
                ^^^^^^^^
Warning 42: this use of DivEqual relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 322, characters 10-15:
322 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 40: Equal was selected from type Ast.assign_op.
It is not visible in the current scope, and will not 
be selected if the type becomes unknown.
File "src/codegen.ml", line 322, characters 10-15:
322 |         | Equal -> ignore(L.build_store e2' e1' builder); e1')
                ^^^^^
Warning 42: this use of Equal relies on type-directed disambiguation,
it will not compile with OCaml 4.00 or earlier.
File "src/codegen.ml", line 203, characters 42-7777:
203 | ..........................................match e with
204 |     SInt_lit i
205 |     -> L.const_int i32_t i
206 |     | SString_lit s
207 |     -> L.build_global_stringptr s "the_str" builder
...
380 |        let result = (match (List.hd fdecl.styp_name) with
381 |        A.Void -> ""
382 |        | _ -> f ^ "_result") in
383 |        L.build_call fdef (Array.of_list llargs) result builder
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SChar_lit _|SCast (_, _)|SListElement (_, _)|SListAddHead (_, _)|
SListAddTail (_, _)|SLength _|SProbColon (_, _)|SIndex _)
File "src/codegen.ml", line 391, characters 25-1851:
391 | .........................function
392 |     SBlock sl -> List.fold_left stmt builder sl
393 |     | SExpr e -> ignore(expr builder e); builder
394 |     | SReturn e -> ignore(match (List.hd fdecl.styp_name) with
395 |                                            (* Special "return nothing" instr *)
...
428 |         let bool_val = expr pred_builder p in
429 | 
430 |       ignore(L.build_cond_br bool_val body_bb merge_bb pred_builder);
431 |       L.builder_at_end context merge_bb
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
(SBreak|SContinue|SIf_Else (_, _)|SIf_Elif (_, _, _)|
SIf_Elif_Else (_, _, _, _)|SElif (_, _))
File "src/codegen.ml", line 85, characters 24-31:
85 |   let genGlobalListLit (typlist,exp) n m =
                             ^^^^^^^
Warning 27: unused variable typlist.
File "src/codegen.ml", line 93, characters 27-30:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                ^^^
Warning 27: unused variable v.
File "src/codegen.ml", line 93, characters 33-37:
93 |           ([A.Int],SInt_lit(v))::rest -> let one = L.const_int i32_t 1 in
                                      ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 180, characters 8-22:
180 |     let int_format_str =
              ^^^^^^^^^^^^^^
Warning 26: unused variable int_format_str.
File "src/codegen.ml", line 192, characters 35-38:
192 |     and add_local m (SVdecl((t, n),exp)) = (* add locals to scope  *)
                                         ^^^
Warning 27: unused variable exp.
File "src/codegen.ml", line 222, characters 30-34:
222 |        ([A.Int],SInt_lit(v))::rest (* ([A.Int],SInt_lit(v))::rest *)
                                    ^^^^
Warning 27: unused variable rest.
File "src/codegen.ml", line 255, characters 16-21:
255 |             let aList = L.build_alloca (L.pointer_type list_t) "theList" in
                      ^^^^^
Warning 26: unused variable aList.
# Target: src/scanner.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/scanner.cmx, file:src/scanner.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/scanner.cmx src/scanner.ml
# Target: src/semant.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/semant.cmx, file:src/semant.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmx src/semant.ml
+ ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/semant.cmx src/semant.ml
File "src/semant.ml", line 6, characters 16-26:
6 | module StdLib = Pervasives
                    ^^^^^^^^^^
Alert deprecated: module Stdlib.Pervasives
Use Stdlib instead.

If you need to stay compatible with OCaml < 4.07, you can use the 
stdlib-shims library: https://github.com/ocaml/stdlib-shims
File "src/semant.ml", line 146, characters 79-80:
146 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                                                     ^
Alert deprecated: Stdlib.&
Use (&&) instead.
File "src/semant.ml", line 262, characters 30-55:
262 |     let initLocals = List.map (fun (Some a) -> SExpr a)
                                    ^^^^^^^^^^^^^^^^^^^^^^^^^
Warning 8: this pattern-matching is not exhaustive.
Here is an example of a case that is not matched:
None
File "src/semant.ml", line 61, characters 19-23:
61 |   let printBind nm typs acc = acc^" ("^nm^")," in
                        ^^^^
Warning 27: unused variable typs.
File "src/semant.ml", line 63, characters 34-35:
63 |   let asBindList = List.map (fun (k,v)-> printBindings v) asScopeList in
                                       ^
Warning 27: unused variable k.
File "src/semant.ml", line 70, characters 6-17:
70 |   let check_binds (kind : string) (binds : vdecl list) =
           ^^^^^^^^^^^
Warning 26: unused variable check_binds.
File "src/semant.ml", line 146, characters 50-53:
146 |       let same = snd (List.fold_left (fun acc (ty,elt) -> (ty, (fst acc == ty) & (snd acc)))
                                                        ^^^
Warning 27: unused variable elt.
File "src/semant.ml", line 224, characters 34-53:
224 |   let check_for_init_local (Vdecl((typs,nm)as binding,e)) = match e with
                                        ^^^^^^^^^^^^^^^^^^^
Warning 26: unused variable binding.
# Target: src/smap.cmx, tags: { package(llvm), package(llvm.analysis), warn(+a-4), compile, extension:cmx, extension:ml, file:src/smap.cmx, file:src/smap.ml, implem, native, ocaml, quiet, traverse }
ocamlfind ocamlopt -c -w +a-4 -package llvm -package llvm.analysis -I src -o src/smap.cmx src/smap.ml
# Target: src/smap.native, tags: { package(llvm), package(llvm.analysis), warn(+a-4), dont_link_with, extension:native, file:src/smap.native, link, native, ocaml, program, quiet, traverse }
ocamlfind ocamlopt -linkpkg -package llvm -package llvm.analysis -I src src/ast.cmx src/sast.cmx src/codegen.cmx src/parser.cmx src/scanner.cmx src/semant.cmx src/smap.cmx -o src/smap.native
# Compilation successful.
